<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XLMaverick - garabatear of yang</title>
    <link>https://xlmaverick.me/</link>
    <description>Recent content on XLMaverick - garabatear of yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 20 Aug 2018 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://xlmaverick.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://xlmaverick.me/about/</link>
      <pubDate>Mon, 20 Aug 2018 21:38:52 +0800</pubDate>
      
      <guid>https://xlmaverick.me/about/</guid>
      
        <description>

&lt;h2 id=&#34;本站架构&#34;&gt;本站架构&lt;/h2&gt;

&lt;p&gt;本站目前采用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;作为后台系统，并且使用&lt;a href=&#34;https://www.netlify.com/&#34;&gt;Netlify&lt;/a&gt;进行部署。&lt;/p&gt;

&lt;p&gt;博客的主题模板是从Hugo官方网站上面&lt;a href=&#34;https://github.com/olOwOlo/hugo-theme-even&#34;&gt;下载&lt;/a&gt;的，在主页的搭建过程中，参考了同实验室朱一帆、王兆圣的博客，同时友情链接里面相关的链接。&lt;/p&gt;

&lt;h2 id=&#34;常见问题&#34;&gt;常见问题&lt;/h2&gt;

&lt;p&gt;本列表特整理重复度很高的问题，供新来者参考。&lt;/p&gt;

&lt;p&gt;1.请问如何订阅这个博客？&lt;/p&gt;

&lt;p&gt;回答： &lt;a href=&#34;https://xlmaverick.me/post/2018/07/07/rss添加/&#34;&gt;可参看这篇博客&lt;/a&gt;，需要利用RSS阅读器。&lt;/p&gt;

&lt;h2 id=&#34;友情链接&#34;&gt;友情链接　　　　　　　　　　　　&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aintk.xyz/&#34;&gt;&lt;strong&gt;隔壁老王&lt;/strong&gt;&lt;/a&gt; 　　　&lt;a href=&#34;https://www.drifter.fun/&#34;&gt;&lt;strong&gt;喜提宝马的朱总&lt;/strong&gt;&lt;/a&gt; 　　　&lt;a href=&#34;https://www.bloodbaby.tech/&#34;&gt;&lt;strong&gt;十亩之间&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yihui.name/&#34;&gt;&lt;strong&gt;谢益辉的独立博客&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>非线性优化</title>
      <link>https://xlmaverick.me/post/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/</guid>
      
        <description>

&lt;h1 id=&#34;非线性优化&#34;&gt;非线性优化&lt;/h1&gt;

&lt;h2 id=&#34;习题一-矩阵微分&#34;&gt;习题一：矩阵微分&lt;/h2&gt;

&lt;p&gt;在优化中经常会遇到矩阵微分的问题。例如,当自变量为向量$x$,求标量函数$u(x)$对$x$的导数时,即为矩阵微分。通常线性代数教材不会深入探讨此事,这往往是矩阵论的内容。回答下列问题:
设变量为$x\in{R^N}$，那么:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;矩阵$A\in{R^{N×N}}$，那么$d(Ax)/dx$是什么？&lt;/li&gt;
&lt;li&gt;矩阵$A\in{R^{N×N}}$，那么$d(x^TAx)/dx$是什么？&lt;/li&gt;

&lt;li&gt;&lt;p&gt;证明：
&lt;p&gt;
$$
x^TA^Tx = tr(Axx^T ).
$$
&lt;/p&gt;&lt;/p&gt;

&lt;h4 id=&#34;分析&#34;&gt;分析&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;涉及到矩阵和向量的求导，总共有五种类型，注意相关的顺序以及于雅各比矩阵的区别，再强调一次，雅各比矩阵的列数为自变量的个数，这一点要记清楚。
A.向量对标量；
B.标量对向量；
C.向量对向量；
D.矩阵对标量；
E.标量对矩阵；
他们分别对应的形式如下所示：&lt;br /&gt;
$$
向量对标量: \frac{\partial{Y}}{\partial{x}} = \begin{bmatrix} \frac{\partial{y_1}}{\partial{x}} \ \frac{\partial{y_2}}{\partial{x}} \  \vdots \ \frac{\partial{y_m}}{\partial{x}} \end{bmatrix}
$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$
 标量对向量: \frac{\partial{y}}{\partial{X}} = \begin{bmatrix} \frac{\partial{y}}{\partial{x_1}} &amp;amp; \frac{\partial{y}}{\partial{x_2}} &amp;amp;  \cdots &amp;amp; \frac{\partial{y}}{\partial{x_n}} \end{bmatrix}
$$&lt;/p&gt;

&lt;p&gt;$$
 向量对向量: \frac{\partial{Y}}{\partial{X}} = \begin{bmatrix} \frac{\partial{y_1}}{\partial{x_1}} &amp;amp; \frac{\partial{y_2}}{\partial{x_1}} &amp;amp;  \cdots &amp;amp; \frac{\partial{y_m}}{\partial{x_1}} \\
 \frac{\partial{y_1}}{\partial{x_2}} &amp;amp; \frac{\partial{y_2}}{\partial{x_2}} &amp;amp;  \cdots &amp;amp; \frac{\partial{y_m}}{\partial{x_2}} \\
 \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
  \frac{\partial{y_1}}{\partial{x_n}} &amp;amp; \frac{\partial{y_2}}{\partial{x_n}} &amp;amp;  \cdots &amp;amp; \frac{\partial{y_m}}{\partial{x_n}} \\
 \end{bmatrix}
$$&lt;/p&gt;

&lt;p&gt;
$$
 矩阵对标量: \frac{\partial{Y}}{\partial{x}} = \begin{bmatrix} \frac{\partial{y_{11}}}{\partial{x}} &amp; \frac{\partial{y_{21}}}{\partial{x}} &amp;  \cdots &amp; \frac{\partial{y_{m1}}}{\partial{x}} \\\\ 
 \frac{\partial{y_{12}}}{\partial{x}} &amp; \frac{\partial{y_{22}}}{\partial{x}} &amp;  \cdots &amp; \frac{\partial{y_{m2}}}{\partial{x}} \\\\ 
 \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\ 
  \frac{\partial{y_{1n}}}{\partial{x}} &amp; \frac{\partial{y_{2n}}}{\partial{x}} &amp;  \cdots &amp; \frac{\partial{y_{mn}}}{\partial{x}} \\\\ 
 \end{bmatrix}
$$
&lt;/p&gt;

&lt;p&gt;
$$
 标量对矩阵: \frac{\partial{y}}{\partial{X}} = \begin{bmatrix} \frac{\partial{y}}{\partial{x_{11}}} &amp; \frac{\partial{y}}{\partial{x_{12}}} &amp;  \cdots &amp; \frac{\partial{y}}{\partial{x_{1n}}} \\
 \frac{\partial{y}}{\partial{x_{21}}} &amp; \frac{\partial{y}}{\partial{x{22}}} &amp;  \cdots &amp; \frac{\partial{y}}{\partial{x_{2n}}} \\
 \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  \frac{\partial{y}}{\partial{x_{m1}}} &amp; \frac{\partial{y}}{\partial{x_{m2}}} &amp;  \cdots &amp; \frac{\partial{y}}{\partial{x_{mn}}} \\
 \end{bmatrix}
$$
&lt;/p&gt;

&lt;p&gt;我们常用的矩阵求导公式有：&lt;/p&gt;

&lt;p&gt;$$
    Y = A * X &amp;ndash;&amp;gt; \frac{\partial{Y}}{\partial{X}} = A^T
$$
$$
    Y = X * A &amp;ndash;&amp;gt; \frac{\partial{Y}}{\partial{X}} = A&lt;br /&gt;
$$
$$
    Y = A^T * X * B &amp;ndash;&amp;gt; \frac{\partial{Y}}{\partial{X}} = A * B^T&lt;br /&gt;
$$
$$
    Y = A^T * X^T * B &amp;ndash;&amp;gt; \frac{\partial{Y}}{\partial{X}} = B * A^T&lt;br /&gt;
$$
$$
    \frac{\partial{X^TX}}{\partial{X}} = X
$$&lt;/p&gt;

&lt;h4 id=&#34;答案&#34;&gt;答案：&lt;/h4&gt;

&lt;p&gt;1、设$Y=AX$，则$Y\in{R^{N*1}}$，所以$\frac{\partial{Y}}{\partial{X}}$属于向量对向量的形式，其中Y向量我们可以计算得出：&lt;/p&gt;

&lt;p&gt;
$$
Y = \begin{bmatrix} a_{11}*x_1+a_{12}*x_2+ \cdots + a_{1n}*x_n\\ 
a_{21}*x_1+a_{22}*x_2+ \cdots + a_{2n}*x_n \\  
\vdots \\ 
a_{n1}*x_1+a_{n2}*x_2+ \cdots + a_{nn}*x_n
\end{bmatrix}
$$
&lt;/p&gt;

&lt;p&gt;则我们由上述向量对向量的式子可以得到：&lt;/p&gt;

&lt;p&gt;
$$
\frac{\partial{Y}}{\partial{X}} = \begin{bmatrix} \frac{\partial{y_1}}{\partial{x_1}} &amp; \frac{\partial{y_2}}{\partial{x_1}} &amp;  \cdots &amp; \frac{\partial{y_m}}{\partial{x_1}} \\
 \frac{\partial{y_1}}{\partial{x_2}} &amp; \frac{\partial{y_2}}{\partial{x_2}} &amp;  \cdots &amp; \frac{\partial{y_m}}{\partial{x_2}} \\
 \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  \frac{\partial{y_1}}{\partial{x_n}} &amp; \frac{\partial{y_2}}{\partial{x_n}} &amp;  \cdots &amp; \frac{\partial{y_m}}{\partial{x_n}} \\
 \end{bmatrix}
 $$
 &lt;/p&gt;

&lt;p&gt;带入YX变量可得：&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
 $$
    \frac{\partial{Y}}{\partial{X}} =
         \begin{pmatrix}
        a_ {11} &amp;amp; a_ {21}  &amp;amp; \cdots &amp;amp; a_ {n1} \\
        a_ {12} &amp;amp; a_ {22} &amp;amp; \cdots &amp;amp; a_ {n2}\\
        \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
        a_ {1n} &amp;amp; a_ {2n} &amp;amp; \cdots &amp;amp; a_ {nn} \\
        \end{pmatrix}
        = A^T
 $$
 &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;2、由第一问我们可以知道，$Y=AX$,我们设 $ Z = x^TY$，则我们可以知道$Z\in{R^{1*1}}$，则&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
 $$
 Z = \sum_ {i=1}^n\sum_ {j=1}^n a_ {ij}*x_i*x_j
 $$
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;则我们由上述标量对向量的式子可以得到：&lt;/p&gt;

&lt;p&gt;
 $$
 \frac{\partial{z}}{\partial{X}} = \begin{bmatrix} \frac{\partial{z}}{\partial{x_1}} &amp; \frac{\partial{z}}{\partial{x_2}} &amp;  \cdots &amp; \frac{\partial{z}}{\partial{x_n}} \end{bmatrix}
 $$
 &lt;/p&gt;

&lt;p&gt;我们计算出Z对与 $x_l$的导数为：&lt;/p&gt;

&lt;p&gt;
 $$
 \frac{\partial{z}}{\partial{x_l}} = \sum_{i=1}^nx_i*a_{il}+\sum_{j=1}^nx_j*a_{lj} = (A^T+A)x
 $$
 &lt;/p&gt;

&lt;p&gt;3、根据上述的第二问，我们可以将$x^TA^Tx$展开，同时可以将$Axx^T$展开，最终我们能够证明$x^TA^Tx = tr(Axx^T)$,这里不再展开叙述。&lt;/p&gt;

&lt;h2 id=&#34;习题二-高斯牛顿法的曲线拟合实验&#34;&gt;习题二：高斯牛顿法的曲线拟合实验&lt;/h2&gt;

&lt;p&gt;我们在课上演示了用&lt;code&gt;Ceres&lt;/code&gt;和&lt;code&gt;g2o&lt;/code&gt;进行曲线拟合的实验,可以看到优化框架给我们带来了诸多便利。本题中你需要自己实现一遍高斯牛顿的迭代过程,求解曲线的参数。我们将原题复述如下。设有曲线满足以下方程:&lt;/p&gt;

&lt;p&gt;
$$
y = exp(ax^2+bx+c)+w
$$
&lt;/p&gt;

&lt;p&gt;其中a,b,c为曲线参数,w为噪声。现有N个数据点(x,y)，希望通过此N个点来拟合a,b,c。实验中取$N = 100$。&lt;br /&gt;
那么，定义误差为 $ e_i = y_i-exp(ax_i^2+bx_i+c)$，于是$(a,b,c)$的最优解可通过解以下最小二乘获得：&lt;/p&gt;

&lt;p&gt;
$$
min_{a b c} = \frac{1}{2}\sum_{i=1}^N {||y_i - exp(ax_i^2+bx_i+c)||^2}
$$
&lt;/p&gt;

&lt;p&gt;现在请你书写 Gauss-Newton 的程序以解决此问题。&lt;/p&gt;

&lt;h4 id=&#34;分析-1&#34;&gt;分析&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;注意雅克比矩阵和矩阵微分的形式不同，雅克比矩阵列数为自变量的个数，例如本题中，雅克比矩阵的大小应为 $1*3$，雅克比矩阵和梯度矩阵的关系$A=J^T$。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;程序计算的时候，100个H矩阵相加，这一点可以考虑为100数据都这样的大矩阵，分模块相乘就是各个小模块相乘再累加的过程。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一阶梯度法就是快速下降法，但是快速下降法过于贪心，容易出现锯齿路线，反而增加了迭代的次数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;二阶梯度法就是牛顿法，缺点是需要计算H矩阵，在大规模的问题中这是很难实现的，我们一般避免计算H矩阵。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一阶和二阶的方法，都是将$f(x)^2$在$x$附近泰勒展开，但是高斯牛顿的方法是将$f(x)$进行一阶泰勒展开。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于列文伯格-马夸尔特的方法，一般认为比高斯牛顿更为健壮，但是它收敛的速度可能会慢于高斯牛顿法，但却在SLAM中大量应用。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;答案-1&#34;&gt;答案&lt;/h4&gt;

&lt;p&gt;程序最终结果如图所示：
&lt;div style=&#34;text-align:center&#34;&gt;
&lt;img src=&#34;../images/非线性优化/result.png&#34;&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;完整程序链接：&lt;a href=&#34;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/vslam_fourteen_lectures/gauessnewton&#34;&gt;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/vslam_fourteen_lectures/gauessnewton&lt;/a&gt;&lt;br /&gt;
代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #include &amp;lt;iostream&amp;gt;
    #include &amp;lt;opencv2/opencv.hpp&amp;gt;
    #include &amp;lt;Eigen/Core&amp;gt;
    #include &amp;lt;Eigen/Dense&amp;gt;

    using namespace std;
    using namespace Eigen;

    int main(int argc, char **argv) 
    {
        double ar = 1.0, br = 2.0, cr = 1.0;         // 真实参数值
        double ae = 2.0, be = -1.0, ce = 5.0;        // 估计参数值
        int N = 100;                                 // 数据点
        double w_sigma = 1.0;                        // 噪声Sigma值
        cv::RNG rng;                                 // OpenCV随机数产生器

        vector&amp;lt;double&amp;gt; x_data, y_data;      // 数据
        for (int i = 0; i &amp;lt; N; i++) 
        {
            double x = i / 100.0;
            x_data.push_back(x);
            y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma));
        }

        // 开始Gauss-Newton迭代
        int iterations = 100;    // 迭代次数
        double cost = 0, lastCost = 0;  // 本次迭代的cost和上一次迭代的cost

        for (int iter = 0; iter &amp;lt; iterations; iter++) 
        {
            Matrix3d H = Matrix3d::Zero();             // Hessian = J^T J in Gauss-Newton
            Vector3d b = Vector3d::Zero();             // bias
            cost = 0;

            for (int i = 0; i &amp;lt; N; i++) 
            {
                double xi = x_data[i], yi = y_data[i];  // 第i个数据点
                double error = 0;   // 第i个数据点的计算误差
                error =yi -exp(ae*xi*xi+be*xi+ce); // 填写计算error的表达式
                Vector3d J; // 雅可比矩阵
                J[0] = -exp(ae*xi*xi+be*xi+ce)*xi*xi;  // de/da
                J[1] = -exp(ae*xi*xi+be*xi+ce)*xi;  // de/db
                J[2] = -exp(ae*xi*xi+be*xi+ce);  // de/dc

                H += J * J.transpose(); // GN近似的H
                b += -error * J;

                cost += error * error;
            }

            // 求解线性方程 Hx=b，建议用ldlt
            Vector3d dx;
            dx = H.ldlt().solve(b);

            if (isnan(dx[0])) 
            {
                cout &amp;lt;&amp;lt; &amp;quot;result is nan!&amp;quot; &amp;lt;&amp;lt; endl;
                break;
            }

            if (iter &amp;gt; 0 &amp;amp;&amp;amp; cost &amp;gt; lastCost) {
                // 误差增长了，说明近似的不够好
                cout &amp;lt;&amp;lt; &amp;quot;cost: &amp;quot; &amp;lt;&amp;lt; cost &amp;lt;&amp;lt; &amp;quot;, last cost: &amp;quot; &amp;lt;&amp;lt; lastCost &amp;lt;&amp;lt; endl;
                break;
            }

            // 更新abc估计值
            ae += dx[0];
            be += dx[1];
            ce += dx[2];

            lastCost = cost;

            cout &amp;lt;&amp;lt; &amp;quot;total cost: &amp;quot; &amp;lt;&amp;lt; cost &amp;lt;&amp;lt; endl;
        }

        cout &amp;lt;&amp;lt; &amp;quot;estimated abc = &amp;quot; &amp;lt;&amp;lt; ae &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; be &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; ce &amp;lt;&amp;lt; endl;
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>相机与图像</title>
      <link>https://xlmaverick.me/post/%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/</guid>
      
        <description>

&lt;h1 id=&#34;相机与图像&#34;&gt;相机与图像&lt;/h1&gt;

&lt;h2 id=&#34;习题一-图像去畸变&#34;&gt;习题一：图像去畸变&lt;/h2&gt;

&lt;p&gt;现实生活中的图像总存在畸变。原则上来说,针孔透视相机应该将三维世界中的直线投影成直线,但是当我们使用广角和鱼眼镜头时,由于畸变的原因,直线在图像里看起来是扭曲的。本次作业,你将尝试如何对一张图像去畸变,得到畸变前的图像。&lt;/p&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
&lt;img src=&#34;../images/相机与图像/test.png&#34; width = &#39;500&#39;&gt;
&lt;/div&gt;

&lt;p&gt;上图为本次练习的测试图片，来自EuRoC数据集。可以明显的看到实际的柱子、箱子的直线边缘在图像中被扭曲成了曲线。这就是由相机畸变造成的。根据我们在课上的介绍,畸变前后的坐标变换为:&lt;/p&gt;

&lt;p&gt;
$$
    \begin {cases}
    x_{distorted} = x(1+k_1r^2+k_2r^4)+2p_1xy+p_2(r^2+2x^2) \\
    y_{distorted} = y(1+k_1r^2+k_2r^4)+p_1(r^2+2y^2)+2p_2xy
    \end {cases}
$$
&lt;/p&gt;

&lt;p&gt;其中 $x,y$为去畸变后的坐标， $x_ {distorted},y_ {distroted}$为去畸变前的坐标。现给定参数:&lt;/p&gt;

&lt;p&gt;$$
    k_1 =−0.28340811,k_2=0.07395907,p_1 = 0.00019359,p_2 = 1.76187114e^{−05}
$$
以及相机内参&lt;/p&gt;

&lt;p&gt;$$
    f_x = 458.654, f_y = 457.296, c_x = 367.215, c_y = 248.375
$$
请根据&lt;code&gt;undistort_image.cpp&lt;/code&gt;文件中内容,完成对该图像的去畸变操作。&lt;/p&gt;

&lt;h4 id=&#34;答案&#34;&gt;答案：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;视觉SALM十四讲中2017年第一版中关于畸变模型的公式是错误的，这一点以这次的为主。畸变公式表示从去畸变后的坐标到去畸变前的坐标变换。&lt;/li&gt;
&lt;li&gt;对其中$r$说明，为极坐标系下的距离，即$r^2=x^2+y^2$&lt;br /&gt;
最终程序的运行结果为：&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&#34;text-align:center&#34;&gt;
&lt;img src=&#34;../images/相机与图像/result.png&#34; width = &#39;500&#39;&gt;
&lt;/div&gt;

&lt;p&gt;完整程序链接：&lt;a href=&#34;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/vslam_fourteen_lectures/undistort&#34;&gt;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/vslam_fourteen_lectures/undistort&lt;/a&gt;&lt;br /&gt;
代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #include &amp;lt;opencv2/opencv.hpp&amp;gt;
    #include &amp;lt;string&amp;gt;
    using namespace std;
    string image_file = &amp;quot;../../test.png&amp;quot;;   // 请确保路径正确
    int main(int argc, char **argv)
    {
        // 本程序需要你自己实现去畸变部分的代码。尽管我们可以调用OpenCV的去畸变，但自己实现一遍有助于理解。
        // 畸变参数
        double k1 = -0.28340811, k2 = 0.07395907, p1 = 0.00019359, p2 = 1.76187114e-05;
        // 内参
        double fx = 458.654, fy = 457.296, cx = 367.215, cy = 248.375;

        cv::Mat image = cv::imread(image_file,0);   // 图像是灰度图，CV_8UC1
        int rows = image.rows, cols = image.cols;
        cv::Mat image_undistort = cv::Mat(rows, cols, CV_8UC1);   // 去畸变以后的图

        // 计算去畸变后图像的内容
        for (int v = 0; v &amp;lt; rows; v++)
        {
            for (int u = 0; u &amp;lt; cols; u++) 
            {
                
                double u_distorted = 0, v_distorted = 0;
                // TODO 按照公式，计算点(u,v)对应到畸变图像中的坐标(u_distorted, v_distorted) (~6 lines)
                // start your code here
                double x = (u-cx)/fx;
                double y = (v-cy)/fy;

                double r2 = x*x+y*y;
                double r4 = r2*r2;

                double x_distorted = x*(1+k1*r2+k2*r4)+2*p1*x*y+p2*(r2+2*x*x);
                double y_distorted = y*(1+k1*r2+k2*r4)+p1*(r2+2*y*y)+2*p2*x*y;

                u_distorted = fx*x_distorted+cx;
                v_distorted = fy*y_distorted+cy;

                // end your code here

                // 赋值 (最近邻插值)
                if (u_distorted &amp;gt;= 0 &amp;amp;&amp;amp; v_distorted &amp;gt;= 0 &amp;amp;&amp;amp; u_distorted &amp;lt; cols &amp;amp;&amp;amp; v_distorted &amp;lt; rows) 
                {
                    image_undistort.at&amp;lt;uchar&amp;gt;(v, u) = image.at&amp;lt;uchar&amp;gt;((int) v_distorted, (int) u_distorted);
                }
                else 
                {
                    image_undistort.at&amp;lt;uchar&amp;gt;(v, u) = 0;
                }
            }
        }
        // 画图去畸变后图像
        cv::imwrite(&amp;quot;../../result.png&amp;quot;, image_undistort);
        cv::imshow(&amp;quot;image undistorted&amp;quot;, image_undistort);
        cv::waitKey();
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;习题二-双目视差的使用&#34;&gt;习题二：双目视差的使用&lt;/h2&gt;

&lt;p&gt;双目相机的一大好处是可以通过左右目的视差来恢复深度。课程中我们介绍了由视差计算深度的过程。本题,你需要根据视差计算深度,进而生成点云数据。本题的数据来自 Kitti 数据集。&lt;br /&gt;
Kitti 中的相机部分使用了一个双目模型。双目采集到左图和右图,然后我们可以通过左右视图恢复出深度。经典双目恢复深度的算法有 BM(Block Matching),SGBM(Semi-Global Matching)等,但本题不探讨立体视觉内容(那是一个大问题)。我们假设双目计算的视差已经给定,请你根据双目模型,画出图像对应的点云,并显示到 Pangolin 中。&lt;br /&gt;
本题给定左右图、视差图。双目的参数如下:
$$
    f_x = 718.856, f_y = 718.856, c_x = 607.1928, c_y = 185.2157
$$
且双目左右间距(即基线)为:
$$
    d = 0.573 m
$$
请根据以上的参数，计算相机数据对应的点云，并显示到Pangolin中。&lt;/p&gt;

&lt;h4 id=&#34;答案-1&#34;&gt;答案：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;注意代码中&lt;code&gt;vector&amp;lt;Vector4d, Eigen::aligned_allocator&amp;lt;Vector4d&amp;gt;&amp;gt; pointcloud&lt;/code&gt;，其中&lt;code&gt;Eigen::aligned_allocator&amp;lt;Vector4d&amp;gt;&lt;/code&gt;是描述&lt;code&gt;vector&lt;/code&gt;中的&lt;code&gt;Allocator type&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;相机模型中使用的是坐标，而相应坐标里面的数值并没有考虑。&lt;/li&gt;
&lt;li&gt;相机的模型中我们共用到四种坐标：世界坐标、相机坐标、归一化相机坐标和像素坐标。其中畸变模型是在归一化相机坐标上讨论的。对于具体的问题，需要考虑合适的正确的坐标对应关系。&lt;/li&gt;
&lt;li&gt;视差图转为深度图信息,公式当中的量纲,双目图片两侧小部分没有视差信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终程序运行的结果（结果中是一个三维的图，前后重叠在一起了）：&lt;br /&gt;
左右图如下所示：&lt;br /&gt;
&lt;div style=&#34;text-align:center&#34;&gt;
&lt;img src=&#34;../images/相机与图像/left.png&#34;  width=&#34;350&#34;/&gt;&lt;img src=&#34;../images/相机与图像/right.png&#34;  width=&#34;350&#34;/&gt;
&lt;/div&gt;
视差图如下所示：&lt;br /&gt;
&lt;div style=&#34;text-align:center&#34;&gt;
&lt;img src=&#34;../images/相机与图像/disparity.png&#34; width=&#34;500&#34;/&gt;
&lt;/div&gt;
最终生成的点云图如下所示：
&lt;div style=&#34;text-align:center&#34;&gt;
&lt;img src=&#34;../images/相机与图像/result1.png&#34; width=&#34;500&#34;/&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;完整程序链接：&lt;a href=&#34;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/vslam_fourteen_lectures/disparity&#34;&gt;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/vslam_fourteen_lectures/disparity&lt;/a&gt;&lt;br /&gt;
代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #include &amp;lt;opencv2/opencv.hpp&amp;gt;
    #include &amp;lt;string&amp;gt;
    #include &amp;lt;Eigen/Core&amp;gt;
    #include &amp;lt;pangolin/pangolin.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;

    using namespace std;
    using namespace Eigen;

    // 文件路径，如果不对，请调整
    string left_file = &amp;quot;../../left.png&amp;quot;;
    string right_file = &amp;quot;../../right.png&amp;quot;;
    string disparity_file = &amp;quot;../../disparity.png&amp;quot;;

    // 在panglin中画图，已写好，无需调整
    void showPointCloud(const vector&amp;lt;Vector4d, Eigen::aligned_allocator&amp;lt;Vector4d&amp;gt;&amp;gt; &amp;amp;pointcloud);

    int main(int argc, char **argv) {

        // 内参
        double fx = 718.856, fy = 718.856, cx = 607.1928, cy = 185.2157;
        // 间距
        double b = 0.573;

        // 读取图像
        cv::Mat left = cv::imread(left_file, 0);
        cv::Mat right = cv::imread(right_file, 0);
        cv::Mat disparity = cv::imread(disparity_file, 0); // disparty 为CV_8U,单位为像素

        // 生成点云
        vector&amp;lt;Vector4d, Eigen::aligned_allocator&amp;lt;Vector4d&amp;gt;&amp;gt; pointcloud;

        // TODO 根据双目模型计算点云
        // 如果你的机器慢，请把后面的v++和u++改成v+=2, u+=2
        for (int v = 0; v &amp;lt; left.rows; v++)
            for (int u = 0; u &amp;lt; left.cols; u++) {

                Vector4d point(0, 0, 0, left.at&amp;lt;uchar&amp;gt;(v, u) / 255.0); // 前三维为xyz,第四维为颜色

                // start your code here (~6 lines)
                // 根据双目模型计算 point 的位置
                uchar  d= disparity.at&amp;lt;uchar&amp;gt;(v,u);
                point[2] = (fx*b)/d;
                point[1] = point[2]*(v-cy)/fy;
                point[0] = point[2]*(u-cx)/fx;
                pointcloud.push_back(point);
                // end your code here
            }
        cout&amp;lt;&amp;lt;&amp;quot;pointcloud size: &amp;quot;&amp;lt;&amp;lt;pointcloud.size()&amp;lt;&amp;lt;endl;
        // 画出点云
        showPointCloud(pointcloud);
        return 0;
    }

    void showPointCloud(const vector&amp;lt;Vector4d, Eigen::aligned_allocator&amp;lt;Vector4d&amp;gt;&amp;gt; &amp;amp;pointcloud) {

        if (pointcloud.empty()) {
            cerr &amp;lt;&amp;lt; &amp;quot;Point cloud is empty!&amp;quot; &amp;lt;&amp;lt; endl;
            return;
        }

        pangolin::CreateWindowAndBind(&amp;quot;Point Cloud Viewer&amp;quot;, 1024, 768);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        pangolin::OpenGlRenderState s_cam(
                pangolin::ProjectionMatrix(1024, 768, 500, 500, 512, 389, 0.1, 1000),
                pangolin::ModelViewLookAt(0, -0.1, -1.8, 0, 0, 0, 0.0, -1.0, 0.0)
        );

        pangolin::View &amp;amp;d_cam = pangolin::CreateDisplay()
                .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f)
                .SetHandler(new pangolin::Handler3D(s_cam));

        while (pangolin::ShouldQuit() == false) {
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            d_cam.Activate(s_cam);
            glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

            glPointSize(2);
            glBegin(GL_POINTS);
            for (auto &amp;amp;p: pointcloud) {
                glColor3f(p[3], p[3], p[3]);
                glVertex3d(p[0], p[1], p[2]);
            }
            glEnd();
            pangolin::FinishFrame();
            usleep(5000);   // sleep 5 ms
        }
        return;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>终食之言--电影春节档</title>
      <link>https://xlmaverick.me/post/%E7%BB%88%E9%A3%9F%E4%B9%8B%E8%A8%80--%E7%94%B5%E5%BD%B1%E6%98%A5%E8%8A%82%E6%A1%A3/</link>
      <pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/%E7%BB%88%E9%A3%9F%E4%B9%8B%E8%A8%80--%E7%94%B5%E5%BD%B1%E6%98%A5%E8%8A%82%E6%A1%A3/</guid>
      
        <description>&lt;p&gt;过年总得有消遣，一群人尬聊，找话题也是件头疼的事，所以啊，有些人一起吃饭，有些人打麻将，诚然，打麻将得需要加赌注，吃饭需要喝酒，总有一个办法调动气氛，打开人的话匣子。后来，感谢党，感谢国家，感谢那一路飙升的GDP，在满足人们日益增长的物质需求的同时，最终没有忘记人们日益增长的文化需求，当然，最终还得靠资本驱动，这几年电影行业的蒸蒸日上，有人名利双收的同时，人们也终于找到了一个不用尬聊，时间也很长，而且参与人员众多的活动，看电影，合大欢喜。&lt;br /&gt;
短短的这几天，流浪地球、疯狂的外星人、飞驰人生，总之大家觉得优秀的片子都随着朋友看着差不多。疯狂外星人中规中矩吧，期待和收获大家都懂。流浪地球，只有一个瑕点，比较讨厌刘启和韩朵朵，每次看到他总想冲上去打他一顿的错觉，难道是年纪大了？总感觉他就是那衬衫上的白米粒,墙上的一抹蚊子血。唉，还是很期待有一天能看到三体也能搬上大屏幕，或者像鬼吹灯一样，做成优质的网剧。最出人意料的还是飞驰人生吧，韩寒还是那一个勇敢无畏的韩寒，我们这一代人，看着他的书，听着他故事的普通人，在这个不三不四的年纪，人五人六的活着，却做着杂七杂八的琐事，很多人谈不上热爱，也谈不上厌恶，却总有一个理由维持着这种状态，还有一些人至今也没找到自己热爱什么啊。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>C&#43;&#43;基础知识--变量和基本类型2</title>
      <link>https://xlmaverick.me/post/c&#43;&#43;%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86--%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B2/</link>
      <pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/c&#43;&#43;%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86--%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B2/</guid>
      
        <description>

&lt;h2 id=&#34;string-vector-array&#34;&gt;string vector array&lt;/h2&gt;

&lt;h3 id=&#34;string&#34;&gt;string&lt;/h3&gt;

&lt;p&gt;1、using的声明最好不要放到头文件中，因为很多地方包含头文件，容易造成命名空间冲突。&lt;br /&gt;
2、string对象会自动忽略开头处的空白，从第一个字符读起，直到遇到下一处的空白结束。&lt;br /&gt;
3、string中getline()函数除外，如果开头有换行符，则直接返回，不会忽略开头处的空白。&lt;br /&gt;
4、string标准库中的size函数，返回的为string::size_type类型的值，该类型的值为无符号的类型，所以使用尤其注意和有符号的变量运算时，有符号的变量会变为无符号的数据，在for和if中很容易出错。&lt;br /&gt;
5、string对象相加，必须确保+号的两端至少有一个string，直接的字符串是不能够直接相加的。&lt;br /&gt;
6、范围for语句：&lt;br /&gt;
&lt;code&gt;string s;
for（auto c: s)&lt;/code&gt;&lt;br /&gt;
使用范围for可以方便遍历string 和vector，同时可以避免string的下标超过范围。&lt;br /&gt;
7、无论什么时候使用下标，一定要检查其合法性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A：下标的类型，可以使用decltype和auto；
B：下标是否超过范围；
C：下标是否可以使用；（空的vector和string尤其注意）  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8、string是c++的标准库，就想定义了大家共同使用的类，所以有一些大家都可以方便使用的类中的方法，举一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string s(&amp;quot;some string&amp;quot;);  
for (decltype(s.size()) index=0; index != s.size() &amp;amp;&amp;amp; !isspace(s[index]); ++index)  
{  
    s[index] = toupper(s[index]); 
}  
cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子主要说明C++中封装的思想和编码的风格。&lt;/p&gt;

&lt;h3 id=&#34;vector&#34;&gt;vector&lt;/h3&gt;

&lt;p&gt;1、vector是模板不是类型，所以vector容纳的为对象，引用不是对象，所以不存在包含引用的vector。&lt;br /&gt;
2、vector列表初始化时，主要看花括号和圆括号，以及类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v1(10)
vector&amp;lt;int&amp;gt; v2{10}
vector&amp;lt;int&amp;gt; v3(10,1)
vector&amp;lt;int&amp;gt; v4{10,1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意区分上述表达式的不同；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vector(string) s1{&amp;quot;hi&amp;quot;}
vector(string) s2(&amp;quot;hi&amp;quot;)//错误
vector(string) s3{10} 
vector(string) s4{10,&amp;quot;hi&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、向vector中添加元素，一般是定义一个空的vector，然后使用push_bsck函数进行添加，这时候是不能使用下标进行赋值的，因为此时是空的vector，不存在下标，添加元素后，可以使用下标进行访问。这种情况经常使用在未知数据数量的时候经常使用。&lt;br /&gt;
4、向vector中添加元素，必须要确保所写的循环正确无误，尤其是循环可能要改变vector对象容量的时候。（如果循环体内部包含向vector对象添加元素的语句，则不能使用范围for循环，因为范围for循环会预知end的位置）。&lt;br /&gt;
5、string和vector大小的比较，均遵循两个原则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A：两个对象的容量不同，但相同位置的元素均相同，则容量大的对象大；  
B：两个对象的元素值不同，则第一对不同的元素值决定大小关系。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6、string和vector有一个区别就是cout打印的区别，string可以直接的使用cout打印出所有的，但是vector是不可以是直接使用cout的，需要使用for或者范围for来cout打印出每一个元素（注意下标问题）。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>C&#43;&#43;基础知识--变量和基本类型1</title>
      <link>https://xlmaverick.me/post/c&#43;&#43;%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86--%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B1/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/c&#43;&#43;%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86--%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B1/</guid>
      
        <description>

&lt;h3 id=&#34;变量和基本类型&#34;&gt;变量和基本类型&lt;/h3&gt;

&lt;p&gt;1、执行浮点运算选用double，以为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几，甚至某些机器上，双精度运算甚至比单精度的快。&lt;br /&gt;
2、当我们赋值无符号类型超过范围时，其结果为该类型表示数值的总数取模后的余数，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned char a = -4 ;     //a的值为-4+256=252   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、当我们赋值有符号类型超过范围时，其结果是无意义的，此时程序可能继续工作，也可能会崩溃，也有可能产生垃圾数据，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signed char a = 256 //此时a是无定义的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、表达式中既有无符号的数字，又有带符号的数字是，会强制转换为无符号的数字。&lt;br /&gt;
5、减法运算带有强制的类型转换，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned char a = 40, b =10;
std::cout&amp;lt;&amp;lt;b-a&amp;lt;&amp;lt;endl;      //此时输出的结果为-30
signed char a = 40, b =10;
std::cout&amp;lt;&amp;lt;b-a&amp;lt;&amp;lt;endl;    //此时输出的结果为-30
unsigned int a = 40, b =10;
std::cout&amp;lt;&amp;lt;b-a&amp;lt;&amp;lt;endl;    //此时输出的结果为4294967266
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为减法运算会将unsigned char 或者signed char转换为int类型后进行减法操作，但是unsigned int不会进行强制转换，这一点很容易出错。&lt;br /&gt;
6、字符和字符串的区别，字符串包含结束符\0，同时是单引号和双引号的区别。&lt;br /&gt;
7、C++中初始化和赋值是两个完全不同的操作，初始化的含义是创建变量的时候赋予其一个初始值，复制的含义是把对象当前的值擦除，用一个新值替代。&lt;br /&gt;
8、变量初始化的方式有四种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; int temp = 0； 
 int temp = {0}；
 int temp = {0}；
 int temp = （0）；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第二种、第三种称作列表初始化，列表初始化时不能进行类型转换。&lt;br /&gt;
9、使用未初始化的变量可能会带来无法预计的后果，建议初始化每一个内置类型的变量。&lt;br /&gt;
10、extern关键字表示声明的含义，extern语句包含初始化值的情况下将不是声明，而是定义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern int i； //声明i而非定义
int i； //定义
extern int i = 2； //定义
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量只能定义一次，但是可以声明多次，尤其是分块编程的时候。&lt;br /&gt;
11、c++变量命名规范：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;标识要能体现实际含义；
变量名一般用小写，例如index，不要使用Index或者INDEX；  
用户自定义的的类名一般以大写字母开头，例如Sale_item；  
如果标识由多个单词组成，则单词应有明显的区分，如student_loan studentLoan；  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，命名规范这件事，若能坚持，必将有效。&lt;br /&gt;
12、在对象第一次使用的地方附近定义它是一种较好的选择，这样有助于找到变量的定义，而且有助于赋给一个合适的初值。&lt;br /&gt;
13、如果函数有可能用到一个全局的变量，则最好不要再定义一个同名的局部变量。（是针对同一个名字在不同的作用域可能指向不同的实体的情况）&lt;br /&gt;
14、引用：引用为对象起另一个名字，引用必须初始化，初始值也必须为一个对象，同时类型应保持一致，而且引用本身不是一个对象，不能定义引用的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ival = 1024;
int &amp;amp;reival = ival;// 正确 引用
int &amp;amp;reval2;// 错误，引用必须初始化
double temp = 3.14；
int &amp;amp;retemp = temp；//错误，引用的类型必须保持一致
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15、指针：指针本身就是一个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期内能先后指向不同的对像。指针无需在定义的时候赋初值，如果指针没有被初始化，将拥有一个不确定的值。但是，使用未经初始化的指针是引发问题的重要原因，建议初始化所有的指针，并且在可能的情况下，尽量定义了对象之后在定义指向他的指针。如果实在不能确定指针指向何处，初始化为nullptr和0，然后在程序中每次使用指针前先进性判断，尽可能的减少错误的可能。&lt;br /&gt;
16、空指针的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int  *p1 = nullptr;//
int  *p2 = 0;//
int  *p3 = NULL;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是把int变量直接赋给指针是错误的操作，即使这个int变量的值等于0；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int zero = 0；
p1 = zero；//错误，不能讲int类型的变量直接赋给指针
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;17、因为引用不是一个实际的对象，故不能定义指向引用的指针；&lt;br /&gt;
18、指针的类型和它所指向的对象的类型需要严格的匹配；&lt;br /&gt;
19、指针定义的时候，和具体使用指针的时候有下面的区别：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int  pd =42; 
int  *p1 = pd; int *p1 =  &amp;amp;pd;//这两种定义的方式都正确 第一种 初始值是指向int对象的指针；第二种是初始值是int型对象的地址。
定义完之后，p1表示地址，*p1表示指向的对象，即pd；
*p1 = &amp;amp;pd//错误
为*p赋值实际是为p1所指向的对象复制，所以*解引用操作只适用于那些明确指向了对象的指针。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;20 、int*  p1 和 int   &lt;em&gt;p1 的作用是一样的，而且int&lt;/em&gt; 没有批量操作的作用，所以这两种写法只要坚持其中的一种即可，在接下来的博客中，均采用第二种方法。&lt;br /&gt;
21、距离变量名最近的符号对变量的类型有最直接的影响：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int p = 42;
int *p1 = &amp;amp;p;
int  **p2 =  &amp;amp;p1;//指向指针的指针
int  *&amp;amp;p3 = p1;//对一个指针的引用
p3 = &amp;amp;p;//p3引用了一个指针，因此可以将地址赋给p3
*p3 = 0; //将p3引用的指针解引用操作，再复制，就是p目前为0。
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>视觉作业-1</title>
      <link>https://xlmaverick.me/post/%E8%A7%86%E8%A7%89%E4%BD%9C%E4%B8%9A-1/</link>
      <pubDate>Thu, 04 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/%E8%A7%86%E8%A7%89%E4%BD%9C%E4%B8%9A-1/</guid>
      
        <description>

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;本学期，由于邹老师开设视觉定位的课程，我们组的大部分人基本每节课都在听，本次课程邹老师总共会设置六次大作业，应该难度不会很大。既然来上课了，所以就把相关的作业也做了。具体的代码和课件，我会放到自己的github上面：&lt;a href=&#34;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/homework_PPT_Zou_2018/Partial_code&#34;&gt;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/homework_PPT_Zou_2018/Partial_code&lt;/a&gt; ；&lt;br /&gt;
第一次作业是Histogram Specialization，是图像处理中基本的操作了，要求是不能使用相关的函数库，具体的要求和代码如下所示：&lt;/p&gt;

&lt;h3 id=&#34;作业要求&#34;&gt;作业要求&lt;/h3&gt;

&lt;p&gt;Write a small program to implement a histogram specialization algorithm.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Consider two brightness mapping functions transform both histograms into a constant histogram:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../images/视觉作业-1/Histogram-1.png&#34; alt=&#34;&#34; /&gt;{:height=&amp;ldquo;50%&amp;rdquo; width=&amp;ldquo;50%&amp;rdquo;}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Algorithm:&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../images/视觉作业-1/Histogram-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;代码说明&#34;&gt;代码说明&lt;/h3&gt;

&lt;p&gt;工程共实现了三种功能，直方图均衡化、直方图特例化和显示直方图。分别对应的函数为：&lt;br /&gt;
cv::Mat histogram_specilalization(cv::Mat srcImage, cv::Mat dstImage)；&lt;br /&gt;
cv::Mat histogram_equalization(cv::Mat srcImage)；&lt;br /&gt;
void histogram_show(cv::Mat srcImage)。&lt;/p&gt;

&lt;p&gt;具体的实现思路如上述的算法所示。&lt;br /&gt;
代码运行方法为：
cd build&lt;br /&gt;
cmake ..&lt;br /&gt;
make&lt;br /&gt;
./Histogram_specialization&lt;/p&gt;

&lt;p&gt;完整程序链接：&lt;a href=&#34;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/homework_PPT_Zou_2018/Partial_code&#34;&gt;https://github.com/XLMaverick/Visual-Localization-Percessing/tree/master/homework_PPT_Zou_2018/Partial_code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>相机模型与标定</title>
      <link>https://xlmaverick.me/post/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%A0%87%E5%AE%9A/</link>
      <pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%A0%87%E5%AE%9A/</guid>
      
        <description>

&lt;p&gt;由于近期使用了很多种不同的相机，关于相机的模型和标定方法也是老生常谈的问题，这也是视觉定位的必要前提，本文只要分为三个部分：坐标系的转换、相机模型和畸变模型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;坐标系转换&lt;br /&gt;
像素坐标、图像坐标、摄像机坐标、世界坐标，其中世界坐标到摄像机坐标为刚体变换、摄像机坐标到图像坐标为透视投影、图像坐标到像素坐标为二次转换，牵扯到的具体的相机的内参矩阵和外参矩阵。&lt;/li&gt;
&lt;li&gt;相机的模型&lt;br /&gt;
相机模型分为针孔模型（线性模型）和非线性模型（鱼眼相机）&lt;/li&gt;
&lt;li&gt;畸变模型&lt;br /&gt;
畸变一般可以分为：径向畸变、切向畸变径向畸变来自于透镜形状。切向畸变来自于整个摄像机的组装过程。对于鱼眼相机，存在比较严重的畸变，主要是径向形变（普通相机也有，也会有轻微的切向形变）。针对具体的标定时，常用的畸变模型有fisheye模型、多项式畸变模型、ATAN模型和FOV模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体的标定工具：&lt;br /&gt;
* Matlab 标定工具箱&lt;br /&gt;
* Ros标定工具&lt;br /&gt;
* opencv标定工具&lt;br /&gt;
* 在github中，邹丹平老师有一套标定代码，我们通常用来标定鱼眼相机，该工具中已有的畸变模型有FOV模型，fisheye模型和Plumb—Bob模型。&lt;br /&gt;
* 对于SVO算法，由于ATAN标定的模型参数便于快速计算，故常采用PTAM中的标定程序来标定ATAN畸变模型。&lt;br /&gt;
上述只是本人常常使用的方法，欢迎大家推荐和指正。&lt;/p&gt;

&lt;h3 id=&#34;总结-2018-10-02&#34;&gt;总结 2018-10-02&lt;/h3&gt;

&lt;p&gt;本次主要是缕清相机模型、畸变模型还有常用的坐标转换之间的关系，同一种相机可以使用不同的畸变模型进行标定。比如，同一种鱼眼相机，可以采用FOV畸变模型进行来标定，同样可以采用ATAN畸变模型进行标定，标定的结果的具体含义是不同的。对于具体的数学关系的推算，以及相应的标定工具的具体使用方法，接下来会详细说明，其中是以邹老师的标定程序为主体框架，详细的介绍标定的代码流程和使用方法，同时也会相应的介绍不同的畸变模型下对应的解畸变方法，具体的代码也会公布到github主页上面。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>github的问题</title>
      <link>https://xlmaverick.me/post/github%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/github%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git 提交github后文件夹为灰颜色问题&lt;br /&gt;
因为使用git clone 之后，文件夹里面会包含原来相关的信息，所以重新push之后会显示灰颜色。解决方案：&lt;br /&gt;
* 删除clone的代码里面的.git和.gitignore文件，重新push。&lt;br /&gt;
* 若上述方法无效时，是因为已经有了缓存，需要先将缓存删除&lt;br /&gt;
git rm -r &amp;ndash;cached some-directory&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git提交空文件夹&lt;br /&gt;
在空目录下创建.gitkeep文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;push 每次需要输入用户名和密码的问题&lt;br /&gt;
每次都需要输入用户名和密码是因为你采用的是 https 方式提交代码， 如果采用的是 ssh 方式只需要在版本库中添加用户的 sha 的key就可以实现提交时无需输入用户名和密码。&lt;br /&gt;
可以在更改配置HTTPS地址为SSH地址，当然也可以通过设置git的cache，可以让它记住密码，之后自己设置一个cache有效时间 这样也一定程度保证了一些安全性，具体代码如下&lt;br /&gt;
git config &amp;ndash;global credential.helper cache&lt;br /&gt;
git config &amp;ndash;global credential.helper &amp;lsquo;cache &amp;ndash;timeout=3600&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>写在博客边上</title>
      <link>https://xlmaverick.me/post/%E5%86%99%E5%9C%A8%E5%8D%9A%E5%AE%A2%E8%BE%B9%E4%B8%8A/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://xlmaverick.me/post/%E5%86%99%E5%9C%A8%E5%8D%9A%E5%AE%A2%E8%BE%B9%E4%B8%8A/</guid>
      
        <description>&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关于这个博客的起因是随机的，关于这个博客的过程是曲折的，关于这个博客的结果，只能是看缘分了。前前后后，断断续续，中间因为比赛的原因暂停、因为论文的原因暂停，幸得朱一帆同学的再三帮忙，终究是还是建立完善起来了，由于一些特殊的原因，很多的经历未曾完善，姑且这样吧。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;凡事贵在一悟，一悟又在久修之后。起初的想法在于记录调试旋翼无人机的点点滴滴，旋翼无人机从机械结构、硬件平台到软件算法，涵盖各个领域，从头搭建一架稳定可控的旋翼无人机，是一件磨人心智的工作，需要一点一滴、反复尝试。想到自己当初是一直渴望有一个成功过的手册指导自己，所以想通过这个开源的博客，把自己踩过的坑、掉过的洞分享记录起来，再方便自己总结和反思的同时，希望能帮助更多的人。第二点在于，研究总是曲折前进的，对一个问题反复思考之后，会有自己的认知，随着时间的推进，可能还会有新的想法，温故而知新，记录过程，反复的推敲，总归不是坏事。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;偶然一啸当空发，孤鸿万里应声泣。经历了一件事后，总归有所感触感悟，当时刻骨铭心，后来不过如此，再细细回味，可能再也不会有当时感觉，甚至在记忆中消失殆尽，岁月长，衣裳薄。开设这个博客，记录的同时，也希望自己不要被一时的感慨感触感悟搞迷糊，凡心所向，素履所往，希望自己不要徒碌碌滞于俗，默默束于情。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天就这样吧，明天还要开组会，以后慢慢补充吧。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>